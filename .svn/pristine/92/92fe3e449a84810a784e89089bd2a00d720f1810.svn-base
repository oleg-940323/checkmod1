using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Timers;
using System.Windows;
using System.Diagnostics;
using System.IO;
using System.Xml.Serialization;

namespace checkmod
{

    public class NetworkHelper
    {
        public static List<IPPair> GetNets()
        {
            List<IPPair> nets = null;
            NetworkInterface[] nics = NetworkInterface.GetAllNetworkInterfaces();

            try
            {
                if (nics != null)
                {
                    foreach (NetworkInterface adapter in nics)
                    {
                        if (adapter != null)
                        {
                            IPInterfaceProperties properties = adapter.GetIPProperties();
                            if (properties != null && properties.UnicastAddresses != null)
                            {
                                foreach (UnicastIPAddressInformation uniIPInfo in properties.UnicastAddresses)
                                {
                                    if (uniIPInfo != null && uniIPInfo.Address != null && uniIPInfo.IPv4Mask != null && !uniIPInfo.IPv4Mask.Equals(IPAddress.Parse("0.0.0.0")))
                                    {
                                        if (nets == null)
                                            nets = new List<IPPair>();
                                        nets.Add(new IPPair(uniIPInfo.Address, uniIPInfo.IPv4Mask));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                //SystemInstances.Engine.MessageService.Error(e.Message);
            }
            return nets;
        }
    }

    public class IPPair
    {
        public IPPair(IPAddress ip, IPAddress mask)
        {
            if (ip == null || mask == null)
                throw new Exception("ip or mask is null");
            this.ip = ip;
            this.mask = mask;
        }

        /// <summary>
        /// 
        /// </summary>
        private IPAddress ip;
        public IPAddress IP
        {
            get { return ip; }
            set { ip = value; }
        }

        /// <summary>
        /// 
        /// </summary>
        private IPAddress mask;
        public IPAddress Mask
        {
            get { return mask; }
            set { mask = value; }
        }
    }

    public class Numeration
    {
        Thread SCThread = null;

        public event EventHandlerLC lost_connect;

        public Numeration(IPEndPoint ip, UdpClient client)
        {
            this.client = client;
            this.ip = ip;
        }

        IPEndPoint ip = null;
        UdpClient client = null;

        // Счетчик отправки эхо
        public int AttemptesSendEcho = 0;

        // Флаг обозначения первой отправки кадра
        public bool f_first_send = true;

        public byte num_unicast  { get; set; }

        public byte num_app { get; set; }

        // Флаг ожидания подтверждения приема конфигурации
        public bool WaitRecConf = false;

        // Флаг ожидания подтверждения приема кадра шлюза
        public bool WaitRecGT = false;

        // Флаг ожидания подтверждения приема кадра карты сигналов
        public bool WaitRecMap = false;

        // Флаг ожидания подтверждения приема команды
        public bool WaitRecComm = false;

        // Флаг ожидания подтверждения приема выходных данных
        public bool WaitRecOutData = false;

        public string header { get; set; }

        public bool stop_send_data = true;

        public byte pos;

        bool f_retry = false;

        public bool f_close = true;

        long elapsedTicks;

        // Запуск таймера максимального времени принятия кадра
        public System.Timers.Timer TimerWaitEcho = new System.Timers.Timer(HeaderDriver.wait_unable_echo);

        // Запуск таймера максимального времени принятия кадра
        public System.Timers.Timer TimerEcho = new System.Timers.Timer(HeaderDriver.period_resend_echo);

        public void OnTimedEventWaitSC(Object source, ElapsedEventArgs e)
        {
            if (SCThread != null)
            {
                TimerEcho.Stop();
                TimerEcho.Start();
            }
            else
            {
                SCThread = new Thread(new ThreadStart(SupportConnect));
                SCThread.Name = "SCThread";
                SCThread.Start();
            }
            
        }

        public void SupportConnect()
        {
            byte[] tempr;

            // Метка времени, отсчет от 1 января 1970 года
            DateTime start_time = new DateTime(1970, 1, 1);

            // Текущее время
            DateTime current_time = DateTime.Now;

            // Количество тиков в промежуток с 1 января 1970 по настоящее время
            elapsedTicks = current_time.Ticks - start_time.Ticks;

            TimeSpan elapsedSpan;

            elapsedSpan = new TimeSpan(elapsedTicks);

            // Размер кадра Эхо определен относительно размера типа метки времени (8 байт)
            byte[] data = new byte[17];

            data[(byte)HeaderDriver.HeaderFrame.len] = 8;

            data[(byte)HeaderDriver.HeaderFrame.type] = (byte)HeaderDriver.type_frame_enum.fEcho;

            data[(byte)HeaderDriver.HeaderFrame.reason] = 1;

            data[(byte)HeaderDriver.HeaderFrame.num] = 0;

            tempr = BitConverter.GetBytes((uint)0);
            Array.Copy(tempr, 0, data, (byte)HeaderDriver.HeaderFrame.res, tempr.Length);

            data[(byte)HeaderDriver.StartPositionInBuffer] = (byte)HeaderDriver.TimeTypeNum.tTimespec;

            tempr = BitConverter.GetBytes((UInt32)elapsedSpan.TotalSeconds);
            Array.Copy(tempr, 0, data, (byte)HeaderDriver.StartPositionInBuffer + 5, tempr.Length);
            tempr = BitConverter.GetBytes((UInt32)(elapsedTicks * 100 - (long)elapsedSpan.TotalSeconds * (long)Math.Pow(10, 9)));
            Array.Copy(tempr, 0, data, (byte)HeaderDriver.StartPositionInBuffer + 1, tempr.Length);

            client.Send(data, data.Length, ip);

            lost_connect(ip, true);

            AttemptesSendEcho = 0;
            TimerEcho.Start();

            while (f_close)
            { 
                if (AttemptesSendEcho >= HeaderDriver.numeration_resend_echo)
                {
                    AttemptesSendEcho = 0;
                    lost_connect(ip, false);
                    break;
                }

                if (f_retry)
                {
                    current_time = DateTime.Now;

                    // Количество тиков в промежуток с 1 января 1970 по настоящее время
                    elapsedTicks = current_time.Ticks - start_time.Ticks;

                    elapsedSpan = new TimeSpan(elapsedTicks);

                    tempr = BitConverter.GetBytes((UInt32)elapsedSpan.TotalSeconds);
                    Array.Copy(tempr, 0, data, (byte)HeaderDriver.StartPositionInBuffer + 5, tempr.Length);
                    tempr = BitConverter.GetBytes((UInt32)(elapsedTicks * 100 - (long)elapsedSpan.TotalSeconds * (long)Math.Pow(10, 9)));
                    Array.Copy(tempr, 0, data, (byte)HeaderDriver.StartPositionInBuffer + 1, tempr.Length);

                    client.Send(data, data.Length, ip);
                    f_retry = false;
                }

                Thread.CurrentThread.Suspend();
            }

            Driver.modules.Remove(ip.ToString());

            this.SCThread = null;
        }

        public void OnTimedEventSC(Object source, ElapsedEventArgs e)
        {
            
            AttemptesSendEcho++;
            f_retry = true;
            if (this.SCThread != null)
                this.SCThread.Resume();
        }

        public void Close()
        {
            f_close = false;
        }
    }

    public class Driver
    {
        public event EventHandler add_module_driver;
        public event EventHandlerReady handler_driver;
        public event AddModuleDelegate data_driver;
        public event EventHandlerLC event_lost_connect;
        public event EventHandlerReady module_log;

        public IPEndPoint ip = null;

        public IPEndPoint ip_port;
        List<IPPair> list_ip;
        public UdpClient client;
        static public Dictionary<String, Numeration> modules = new Dictionary<String, Numeration>();
        public bool forever = true;

        // Запись в кольцевой буфер
        public bool f_enable_write_data = true;

        public bool f_reset_ring_buffer = true;

        // Флаг переотправки буфера
        private bool RetrySend = false;

        object locker = new object();

        // Счетчик оправлений конфигурации
        private int AttemptesSend = 0;

        // Запуск таймера максимального времени принятия кадра
        public System.Timers.Timer TimerRec = new System.Timers.Timer(HeaderDriver.max_wait_time);

        public object Dispatcher { get; private set; }

        public Driver()
        {

            TimerRec.Elapsed += OnTimedEvent;
            TimerRec.AutoReset = true;

            list_ip = NetworkHelper.GetNets();
            if (list_ip == null)
                MessageBox.Show("Нет IP адресов");
            else
            {
                foreach (IPPair p in list_ip)
                {
                    if (p.IP.ToString() == HeaderDriver.ip.ToString())
                    {
                        byte[] empty = new byte[10];
                        ip_port = new IPEndPoint(HeaderDriver.ip, HeaderDriver.Port);

                        // Костыль
                        IPEndPoint remote_ip = new IPEndPoint(HeaderDriver.ip_multi_send, HeaderDriver.Port + 1);
                        try
                        {
                            client = new UdpClient(ip_port);
                            client.Send(empty, empty.Length, remote_ip);
                        }
                        catch (Exception ex)
                        {
                            MessageBox.Show(String.Format("IP адрес: {0}\n{1}", HeaderDriver.ip.ToString(), ex.Message));
                            Application.Current.MainWindow.Close();
                        }
                        // Костыль

                        break;
                    }
                }
            }
        }

        public void DriverClose()
        {
            forever = false;
            foreach (string i in modules.Keys)
                modules[i].stop_send_data = false;
        }

        // Сброс нумерации
        public void ResetNum(Numeration num)
    {
        // Сбрасываем нумерацию
        num.f_first_send = true;
        num.num_unicast = 0;
        num.num_app = 0;
    }

        private Thread ThreadProccessData = null;

        public void Recieve()
        {
            int i, start = 3;
            byte[] data;
            byte[] tempr, str;
            Numeration num = null;
            string modname = null, variation = null;
            
            client.Client.ReceiveTimeout = 1;

            while (forever)
            {
                if (client == null)
                {
                    MessageBox.Show(String.Format("Сокет с адресом: {0} и портом: {1} не создан", HeaderDriver.ip.ToString(), HeaderDriver.Port.ToString()));
                    break;
                }

                try
                {
                    // Копируем входищие данные в буфер
                    lock (locker) { data = client.Receive(ref ip); };
                    
                    if (modules.TryGetValue(ip.Address.ToString(), out num))
                    {
                        lock (locker)
                        {
                            num.TimerEcho.Stop();
                            num.TimerWaitEcho.Stop();
                            num.AttemptesSendEcho = 0;
                            num.TimerWaitEcho.Start();
                        };
                    }

                    // Проверка типа кадра
                    switch (data[(byte)HeaderDriver.HeaderFrame.type])
                    {
                        // Принят идентификационный кадр
                        case (byte)HeaderDriver.type_frame_enum.fident:

                            if (data.Length > HeaderDriver.LenHeader)
                                tempr = new byte[data.Length - HeaderDriver.LenHeader];
                            else break;

                            // Убираем из буфера заголовок
                            Array.Copy(data, HeaderDriver.StartPositionInBuffer, tempr, 0, data.Length - HeaderDriver.StartPositionInBuffer);

                            for (int j = 0; j <= 2; j++)
                            {
                                // Поиск строк в буфере
                                for (i = start; (char)tempr[i] != '\0'; i++)
                                    ;

                                str = new byte[i - start];
                                Array.Copy(tempr, start, str, 0, i - start);
                                if (j == 0)
                                    modname = Encoding.ASCII.GetString(str);
                                else if (j == 2)
                                    variation = Encoding.ASCII.GetString(str).Trim(new char[] { '\"' });
                                start = ++i;
                            }

                            start = 3;

                            // Добавление модуля в словарь при отсутствии его в словаре
                            if (add_module_driver(tempr, ip) == 1)
                            {
                                Ack(data, (byte)HeaderDriver.CodeNum.cOk, ip);

                                if (modules.ContainsKey(ip.Address.ToString()))
                                {
                                    lock (locker)
                                    {
                                        modules.TryGetValue(ip.Address.ToString(), out num);
                                        num.num_app = 0;
                                        num.num_unicast = 0;
                                        num.pos = tempr[(byte)SeqIdentDataInCollect.position];
                                        num.header = modname + " " + variation + "(" + num.pos.ToString() + ")";
                                    };
                                    
                                }
                                else
                                {
                                    lock (locker)
                                    {
                                        num = new Numeration(ip, client);
                                        num.lost_connect += LC_Event;
                                        num.num_app = 0;
                                        num.num_unicast = 0;
                                        num.pos = tempr[(byte)SeqIdentDataInCollect.position];
                                        num.header = modname + " " + variation + "(" + num.pos.ToString() + ")";

                                        num.TimerEcho.Elapsed += num.OnTimedEventSC;
                                        num.TimerEcho.AutoReset = true;

                                        num.TimerWaitEcho.Elapsed += num.OnTimedEventWaitSC;
                                        num.TimerWaitEcho.AutoReset = false;
                                        byte b = num.pos;

                                        modules.Add(ip.Address.ToString(), num);

                                        Helper.ring_buffer.Add(ip.Address, new RingBuffer<byte[]>(StartThreads, StopThreads));

                                        Thread ThreadData = new Thread(delegate () { RecieveData(b); });
                                        ThreadData.Name = "RecieveData " + num.pos.ToString();
                                        ThreadData.Start();
                                        Helper.dictionary_threades.Add(num.pos, new List<Thread> {ThreadData});

                                        ThreadProccessData = new Thread(delegate () { ProccessData(ip); });
                                        ThreadProccessData.Name = "ProccessData " + num.pos.ToString();
                                        ThreadProccessData.Start();
                                        Helper.dictionary_threades[num.pos].Add(ThreadProccessData); ;
                                    };
                                }
                            }
                            else
                                Ack(data, (byte)HeaderDriver.CodeNum.cDuble, ip);
                            break;

                        // Принят кадр конфигурации
                        case (byte)HeaderDriver.type_frame_enum.fConfig:

                            // Явлется ли данный кадр подтверждением на принятие кадра с конфигурацией
                            if (data[(byte)HeaderDriver.HeaderFrame.reason] == (byte)HeaderDriver.ReasonSendEnum.rAck)
                                if (modules.ContainsKey(ip.Address.ToString()))
                                {
                                    modules.TryGetValue(ip.Address.ToString(), out num);
                                    if (num.num_app == data[(byte)HeaderDriver.HeaderFrame.num])
                                        lock (locker) { num.WaitRecConf = false; };
                                }
                            break;

                        // Принят кадр команды
                        case (byte)HeaderDriver.type_frame_enum.fCommand:

                            // Явлется ли данный кадр подтверждением на принятие кадра с командой
                            if (data[(byte)HeaderDriver.HeaderFrame.reason] == (byte)HeaderDriver.ReasonSendEnum.rAck)
                            {
                                if (modules.ContainsKey(ip.Address.ToString()))
                                {
                                    modules.TryGetValue(ip.Address.ToString(), out num);
                                    lock (locker) { num.WaitRecComm = false; };
                                }
                            }
                            break;

                        // Принят кадр выходных сигналов
                        case (byte)HeaderDriver.type_frame_enum.fDataOutput:

                            // Явлется ли данный кадр подтверждением на принятие кадра с выходными сигналами
                            if (data[(byte)HeaderDriver.HeaderFrame.reason] == (byte)HeaderDriver.ReasonSendEnum.rAck)
                            {
                                if (modules.ContainsKey(ip.Address.ToString()))
                                {
                                    modules.TryGetValue(ip.Address.ToString(), out num);
                                    lock (locker) { num.WaitRecOutData = false; };
                                }
                            }
                            break;

                        // Принят кадр шлюза
                        case (byte)HeaderDriver.type_frame_enum.fGateway:

                            // Явлется ли данный кадр подтверждением на принятие кадра шлюза
                            if (data[(byte)HeaderDriver.HeaderFrame.reason] == (byte)HeaderDriver.ReasonSendEnum.rAck)
                            {
                                if (modules.ContainsKey(ip.Address.ToString()))
                                {
                                    modules.TryGetValue(ip.Address.ToString(), out num);
                                    lock (locker) { num.WaitRecGT = false; };
                                }
                            }
                            break;

                        // Принят кадр готовности к работе
                        case (byte)HeaderDriver.type_frame_enum.fReady:

                            if (data[(byte)HeaderDriver.HeaderFrame.reason] == (byte)HeaderDriver.ReasonSendEnum.rData_OneAck)
                                if (modules.ContainsKey(ip.Address.ToString()))
                                {
                                    if (modules.TryGetValue(ip.Address.ToString(), out num))
                                        if (num.num_unicast == data[(byte)HeaderDriver.HeaderFrame.num])
                                            Ack(data, (byte)HeaderDriver.CodeNum.cDuble, ip);
                                        else
                                            Ack(data, (byte)HeaderDriver.CodeNum.cOk, ip);

                                    tempr = new byte[data.Length - HeaderDriver.LenHeader];

                                    try
                                    {
                                        Array.Copy(data, HeaderDriver.LenHeader, tempr, 0, tempr.Length);
                                    }
                                    catch (Exception ex)
                                    {
                                        MessageBox.Show(ex.ToString());
                                    }

                                    handler_driver(tempr, ip); 
                                }
                            break;

                        // Принят кадр карты сигналов
                        case (byte)HeaderDriver.type_frame_enum.fMap:

                            // Явлется ли данный кадр подтверждением на принятие кадра карты сигналов
                            if (data[(byte)HeaderDriver.HeaderFrame.reason] == (byte)HeaderDriver.ReasonSendEnum.rAck)
                            {
                                if (modules.ContainsKey(ip.Address.ToString()))
                                {
                                    modules.TryGetValue(ip.Address.ToString(), out num);
                                    lock (locker) { num.WaitRecMap = false; };
                                }
                                break;
                            }
                            break;

                        // Принят стартовый кадр
                        case (byte)HeaderDriver.type_frame_enum.fStart:
                            
                            if (data[(byte)HeaderDriver.HeaderFrame.reason] == (byte)HeaderDriver.ReasonSendEnum.rData_OneAck)
                            {
                                modules.TryGetValue(ip.Address.ToString(), out num);
                                Ack(data, (byte)HeaderDriver.CodeNum.cOk, ip);
                            }
                            break;

                        // Принят кадр логов
                        case (byte)HeaderDriver.type_frame_enum.fLog:
                            tempr = new byte[data.Length - HeaderDriver.LenHeader];
                            Ack(data, (byte)HeaderDriver.CodeNum.cOk, ip);

                            // Убираем из буфера заголовок
                            Array.Copy(data, HeaderDriver.StartPositionInBuffer, tempr, 0, data.Length - HeaderDriver.StartPositionInBuffer);
                            module_log(tempr, ip);
                            break;

                        // Принят кадр "Эхо"
                        case (byte)HeaderDriver.type_frame_enum.fEcho:

                            if (data[(byte)HeaderDriver.HeaderFrame.reason] != 1)
                                Echo(ip, data);
                            else
                            {
                                if (modules.TryGetValue(ip.Address.ToString(), out num))
                                {
                                    lock (locker)
                                    {
                                        num.TimerEcho.Stop();
                                        num.AttemptesSendEcho = 0;
                                    };
                                }
                            }
                            break;
                        default:
                            break;
                    }
                }
                catch (Exception ex)
                {
                    //MessageBox.Show(ex.ToString());
                }
            }

        }

        public void LC_Event(IPEndPoint ip, bool state)
        {
            event_lost_connect(ip, state);
        }

        public void RecieveData(byte pos)
        {
            byte[] data, arr = new byte[10];

            IPEndPoint ip_port_multi = new IPEndPoint(HeaderDriver.ip, HeaderDriver.PortMulti + pos);
            IPEndPoint ip_port_multi2 = new IPEndPoint(HeaderDriver.ip_multi_rec, HeaderDriver.PortMulti + pos);
            IPEndPoint remote_ip_port = null;

            UdpClient udp_multi = new UdpClient(ip_port_multi);
            udp_multi.Send(arr, arr.Length, ip_port_multi2);
            udp_multi.JoinMulticastGroup(HeaderDriver.ip_multi_rec);
            udp_multi.Client.ReceiveTimeout = 1;

            while (forever)
            {
                if (remote_ip_port != null)
                    if ((Helper.ring_buffer.ContainsKey(remote_ip_port.Address)) && (Helper.ring_buffer[remote_ip_port.Address].Count == 0))
                        f_enable_write_data = true;
                if (f_enable_write_data)
                    try
                    {
                        data = udp_multi.Receive(ref remote_ip_port);
                        Helper.ring_buffer[remote_ip_port.Address].Enqueue(data);
                    }
                    catch
                    {
                        udp_multi.Send(arr, arr.Length, ip_port_multi2);
                    }
            }
        }

        public void ProccessData(IPEndPoint remote_ip_port)
        {
            byte[] tempr, data, arr = new byte[10];
            Numeration num = null;
            
            while (forever)
            {
                if ((Helper.ring_buffer.ContainsKey(remote_ip_port.Address)) && (Helper.ring_buffer[remote_ip_port.Address].Count > 0))
                {
                    data = Helper.ring_buffer[remote_ip_port.Address].Dequeue();

                    if (data[(byte)HeaderDriver.HeaderFrame.type] == (byte)HeaderDriver.type_frame_enum.fModSig)
                    {
                        tempr = new byte[data.Length - HeaderDriver.LenHeader];
                        Array.Copy(data, HeaderDriver.StartPositionInBuffer, tempr, 0, data.Length - HeaderDriver.LenHeader);
                        data_driver(tempr, remote_ip_port);
                    }
                    if (stopf)
                        ProcStopThread();
                }
                else
                    Thread.Sleep(500);
            }
        }

        public bool stopf = false;

        public void ProcStopThread()
        {
            if (ThreadProccessData.ThreadState == System.Threading.ThreadState.Running)
            {
                ThreadProccessData.Suspend();
                stopf = false;
            }
        }

        public void StopThreads()
        {
            stopf = true;
        }

        public void StartThreads()
        {
            if (ThreadProccessData.ThreadState == System.Threading.ThreadState.Suspended)
            ThreadProccessData.Resume();
        }

        public int SendConfig(byte[] data, string ip, int port)
        {
            byte[] tempr;
            IPAddress _ip;
            Numeration num = null;

            if (data == null) return 1;

            if (!IPAddress.TryParse(ip, out _ip))
                return 2;

            tempr = new byte[data.Length + HeaderDriver.LenHeader];

            // Длина заголовка
            tempr[(byte)HeaderDriver.HeaderFrame.len] = (byte)HeaderDriver.LenHeader;

            // Тип кадра
            tempr[(byte)HeaderDriver.HeaderFrame.type] = (byte)HeaderDriver.type_frame_enum.fConfig;

            // Причина передачи
            tempr[(byte)HeaderDriver.HeaderFrame.reason] = (byte)HeaderDriver.ReasonSendEnum.rData_OneAck;

            // Нумерация
            if (modules.ContainsKey(ip))
            {
                lock (locker)
                {
                    modules.TryGetValue(ip, out num);
                };

                lock (locker)
                {
                    if (num.f_first_send)
                    {
                        tempr[(byte)HeaderDriver.HeaderFrame.num] = 0;
                        num.f_first_send = false;
                    }
                    else
                    {
                        if (num.num_app == 255)
                            num.num_app = 1;
                        else if (num.num_app >= 0)
                            num.num_app++;
                        tempr[(byte)HeaderDriver.HeaderFrame.num] = num.num_app;
                    }
                };
            }
            else
            {
                // Отсутствует модуль в списке
                return 4;
            }

            // Резерв
            byte[] rs = BitConverter.GetBytes(HeaderDriver.reserve);
            Array.Copy(rs, 0, tempr, (byte)HeaderDriver.HeaderFrame.res, rs.Length);

            Array.Copy(data, 0, tempr, (byte)HeaderDriver.StartPositionInBuffer, data.Length);

            client.Send(tempr, tempr.Length, _ip.ToString(), port);

            lock (locker)
            {
                if (num == null)
                {
                    while (!modules.TryGetValue(ip, out num))
                    {
                        Thread.Sleep(1);
                    }
                        num.WaitRecConf = true;
                }
            };
            AttemptesSend = 0;

            // Запуск таймера подтверждения принятия кадра конфигурации
            TimerRec.Start();

            while (forever)
            {
                lock (locker)
                {
                    if (num.WaitRecConf == false)
                    {
                        TimerRec.Stop();
                        break;
                    }
                };

                // Проверка параметра, который отвечает за количество переповторов. Если = 0, то отправляем неограничемое число раз
                if (!HeaderDriver.f_unable_infinite)
                    // Отправка сброса при отсутствии ответа на 3 итерации отправки конфигурации
                    if (AttemptesSend >= HeaderDriver.numeration_resend)
                    {
                        TimerRec.Stop();
                        RetrySend = false;
                        MessageBox.Show(string.Format("ip:{0} - не получено подтверждения принятия конфигурации", ip));
                        AttemptesSend = 0;
                        return 3;
                    }

                if (RetrySend)
                {
                    client.Send(tempr, tempr.Length, _ip.ToString(), port);
                    RetrySend = false;
                }
            }
            return 0;
        }

        public int SendData(byte[] data, string ip, int port)
        {
            Numeration num = null;
            modules[ip].stop_send_data = true;

            byte[] tempr;
            IPAddress _ip;

            if (data == null) return 1;

            if (!IPAddress.TryParse(ip, out _ip))
                return 2;

            tempr = new byte[data.Length + HeaderDriver.LenHeader];

            // Длина заголовка
            tempr[(byte)HeaderDriver.HeaderFrame.len] = (byte)HeaderDriver.LenHeader;

            // Тип кадра
            tempr[(byte)HeaderDriver.HeaderFrame.type] = (byte)HeaderDriver.type_frame_enum.fDataOutput;

            // Причина передачи
            tempr[(byte)HeaderDriver.HeaderFrame.reason] = (byte)HeaderDriver.ReasonSendEnum.rData_OneAck;

            // Нумерация
            if (modules.ContainsKey(ip))
            {
                modules.TryGetValue(ip, out num);
                lock (locker)
                {
                    if (num.f_first_send)
                    {
                        tempr[(byte)HeaderDriver.HeaderFrame.num] = 0;
                        num.f_first_send = false;
                    }
                    else
                    {
                        if (num.num_app == 255)
                            num.num_app = 1;
                        else if (num.num_app >= 0)
                            num.num_app++;
                        tempr[(byte)HeaderDriver.HeaderFrame.num] = num.num_app;
                    }
                };
            }
            else
                return 4;

            // Резерв
            byte[] rs = BitConverter.GetBytes(HeaderDriver.reserve);
            Array.Copy(rs, 0, tempr, (byte)HeaderDriver.HeaderFrame.res, rs.Length);

            Array.Copy(data, 0, tempr, (byte)HeaderDriver.StartPositionInBuffer, data.Length);

            client.Send(tempr, tempr.Length, _ip.ToString(), port);

            num.WaitRecOutData = true;
            AttemptesSend = 0;

            // Запуск таймера подтверждения принятия кадра конфигурации
            TimerRec.Start();

            while (modules[ip].stop_send_data)
            {
                if (num.WaitRecOutData == false)
                {
                    TimerRec.Stop();
                    break;
                }

                // Проверка параметра, который отвечает за количество переповторов. Если = 0, то отправляем неограничемое число раз
                if (!HeaderDriver.f_unable_infinite)
                    // Отправка сброса при отсутствии ответа на 5 итерации отправки конфигурации
                    if (AttemptesSend >= HeaderDriver.numeration_resend)
                    {
                        TimerRec.Stop();
                        RetrySend = false;
                        AttemptesSend = 0;
                        return 3;
                    }

                if (RetrySend)
                {
                    client.Send(tempr, tempr.Length, _ip.ToString(), port);
                    RetrySend = false;
                }
            }

            // Проверка параметра, который отвечает за количество переповторов. Если = 0, то отправляем неограничемое число раз
            if (HeaderDriver.f_unable_infinite)
            {
                tempr[(byte)HeaderDriver.HeaderFrame.reason] = (byte)HeaderDriver.ReasonSendEnum.rData_NoAck;

                while (modules[ip].stop_send_data)
                {
                    client.Send(tempr, tempr.Length, _ip.ToString(), port);
                    Thread.Sleep(HeaderDriver.retry_time);
                }
            }
            return 0;
        }

        /// <summary>
        /// Метод возвращает следующие значения:
        /// *   0 - Конфигурация отправлена и принята модулем в случае уникаста.
        /// *   1 - Неверно введен IP.
        /// *   2 - Модуль был не идентифицирован.
        /// *   3 - Модуль не подтвердил принятия команды.
        /// </summary>
        /// <param name="type_send">Способ отправки. true - уникаст, false - мультикаст.</param>
        /// <param name="command">
        ///  command - Команда. Имеет следущие значения:
        /// *   WarmReset  - Сброс текущего состояния исполнения на модулях и ЦПС (Горячий сброс)
        /// *   ColdReset  - Сброс модуля и переход к процессу идентификации (Холодный сброс)
        /// *   Stop  - Остановка работы модулей и ЦПС
        /// *   Start - Запуск работы модулей и ЦПС
        /// <param name="ip"> IP не нужно вводить при мультикаст передаче.</param>
        /// </param>
        /// <returns></returns>
        public int SendCommand(bool type_send, byte command, string ip = null)
        {
            int count_start = 0;
            IPAddress _ip = null;
            Numeration num = null;
            byte[] data = new byte[9];

            if (ip == null)
            {     
                IPEndPoint remote_ip = new IPEndPoint(HeaderDriver.ip_multi_send, HeaderDriver.Port + 1);
            }
            else if (!IPAddress.TryParse(ip, out _ip))
                return 1;

            if (type_send)
            {

                data = new byte[1 + HeaderDriver.LenHeader];

                // Длина заголовка
                data[(byte)HeaderDriver.HeaderFrame.len] = (byte)HeaderDriver.LenHeader;

                // Тип кадра
                data[(byte)HeaderDriver.HeaderFrame.type] = (byte)HeaderDriver.type_frame_enum.fCommand;

                // Причина передачи
                data[(byte)HeaderDriver.HeaderFrame.reason] = (byte)HeaderDriver.ReasonSendEnum.rData_OneAck;

                // Нумерация
                if (modules.ContainsKey(ip))
                {
                    modules.TryGetValue(ip, out num);
                    lock (locker)
                    {
                        if (num.f_first_send)
                        {
                            data[(byte)HeaderDriver.HeaderFrame.num] = 0;
                            num.num_app = 0;
                            num.f_first_send = false;
                        }
                        else
                        {
                            if (num.num_app == 255)
                                num.num_app = 1;
                            else if (num.num_app >= 0)
                                num.num_app++;
                            data[(byte)HeaderDriver.HeaderFrame.num] = num.num_app;
                        }
                    };
                }
                else
                    return 2;

                // Резерв
                byte[] rs = BitConverter.GetBytes(HeaderDriver.reserve);
                Array.Copy(rs, 0, data, (byte)HeaderDriver.HeaderFrame.res, rs.Length);

                // Команда
                data[(byte)HeaderDriver.StartPositionInBuffer] = command;

                // Отключение постоянной отправки выходных данных
                if (command != (byte)HeaderDriver.ListCommand.Start)
                    modules[ip].stop_send_data = false;

                client.Send(data, data.Length, _ip.ToString(), HeaderDriver.Port + 1);

                lock (locker) { num.WaitRecComm = true; };
                AttemptesSend = 0;

                // Запуск таймера подтверждения принятия кадра
                TimerRec.Start();

                while (forever)
                {
                    lock (locker)
                    {
                        if (num.WaitRecComm == false)
                        {
                            TimerRec.Stop();
                            if (command == (byte)HeaderDriver.ListCommand.ColdReset)
                            {
                                    num.num_app = 0;
                                    num.num_unicast = 0;
                            }

                            break;
                        }
                    };

                    if (!HeaderDriver.f_unable_infinite)
                        // Отправка сброса при отсутствии ответа на n итерации отправки кадра
                        if (AttemptesSend >= HeaderDriver.numeration_resend)
                        {
                            TimerRec.Stop();
                            RetrySend = false;
                            AttemptesSend = 0;
                            return 3;
                        }

                    if (RetrySend)
                    {
                        client.Send(data, data.Length, _ip.ToString(), HeaderDriver.Port + 1);
                        RetrySend = false;
                    }
                }
                return 0;
            }
            else
            {

                // Размер заголовка
                data[(byte)HeaderDriver.HeaderFrame.len] = (byte)HeaderDriver.LenHeader;

                // Тип кадра 
                data[(byte)HeaderDriver.HeaderFrame.type] = (byte)HeaderDriver.type_frame_enum.fCommand;

                // Причина передачи
                data[(byte)HeaderDriver.HeaderFrame.reason] = (byte)HeaderDriver.ReasonSendEnum.rData_Multi;

                // Нумерация
                data[(byte)HeaderDriver.HeaderFrame.num] = 0;

                // Резерв
                byte[] rs = BitConverter.GetBytes(HeaderDriver.reserve);
                Array.Copy(rs, 0, data, (byte)HeaderDriver.HeaderFrame.res, rs.Length);

                // Команда
                data[(byte)HeaderDriver.LenHeader] = command;

                // Отключение постоянной отправки выходных данных
                if (command != (byte)HeaderDriver.ListCommand.Start)
                    foreach (string i in modules.Keys)
                        modules[i].stop_send_data = false;

                while (count_start < HeaderDriver.num_send_multi)
                {
                    client.Send(data, data.Length, HeaderDriver.ip_multi_send.ToString(), HeaderDriver.Port + 1);
                    count_start++;
                    Thread.Sleep(HeaderDriver.time_multi);
                }
                count_start = 0;
            }
            return 0;
        }

        private void OnTimedEvent(Object source, ElapsedEventArgs e)
            {
                AttemptesSend++;
                RetrySend = true;
            }

        public void Ack(byte[] data, byte apply, IPEndPoint ip)
        {
            Numeration num = null;

            byte[] dt = new byte[HeaderDriver.LenHeader + 1];

            // Размер заголовка
            dt[(byte)HeaderDriver.HeaderFrame.len] = (byte)HeaderDriver.LenHeader;

            // Тип кадра 
            dt[(byte)HeaderDriver.HeaderFrame.type] = data[(byte)HeaderDriver.HeaderFrame.type];

            // Причина передачи
            dt[(byte)HeaderDriver.HeaderFrame.reason] = (byte)HeaderDriver.ReasonSendEnum.rAck;

            // Нумерация
            dt[(byte)HeaderDriver.HeaderFrame.num] = data[(byte)HeaderDriver.HeaderFrame.num];

            // Запись в словарь нумерации модуля
            if (modules.ContainsKey(ip.Address.ToString()))
            {
                modules.TryGetValue(ip.Address.ToString(), out num);
                lock (locker) { num.num_unicast = data[(byte)HeaderDriver.HeaderFrame.num]; };
            }

            // Резерв
            byte[] rs = BitConverter.GetBytes(HeaderDriver.reserve);
            Array.Copy(rs, 0, dt, (byte)HeaderDriver.HeaderFrame.res, rs.Length);

            // Код подтверждения
            dt[HeaderDriver.StartPositionInBuffer] = apply;

             client.Send(dt, dt.Length, ip.Address.ToString(), ip.Port);
        }

        public void Echo(IPEndPoint ip, byte[] data)
        {
            Numeration num = null;
            if (modules.TryGetValue(ip.Address.ToString(), out num))
            {
                if (num.pos == data[2])
                {
                    /*
                    byte[] tempr;

                    long elapsedTicks;

                    // Метка времени, отсчет от 1 января 1970 года
                    DateTime start_time = new DateTime(1970, 1, 1);

                    // Текущее время
                    DateTime current_time = DateTime.Now;
                     
                    // Количество тиков в промежуток с 1 января 1970 по настоящее время
                    elapsedTicks = current_time.Ticks - start_time.Ticks;

                    TimeSpan elapsedSpan = new TimeSpan(elapsedTicks);

                    tempr = BitConverter.GetBytes((UInt32)elapsedSpan.TotalSeconds);
                    Array.Copy(tempr, 0, data, (byte)HeaderDriver.StartPositionInBuffer + 5, tempr.Length);
                    tempr = BitConverter.GetBytes((UInt32)(elapsedTicks * 100 - (long)elapsedSpan.TotalSeconds * (long)Math.Pow(10, 9)));
                    Array.Copy(tempr, 0, data, (byte)HeaderDriver.StartPositionInBuffer + 1, tempr.Length);
                    */
                    client.Send(data, data.Length, ip);
                }
            }
        }
    }
}
